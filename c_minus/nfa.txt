
PÃ¡gina
1
de 14
20/05/25
1
AutÃ³matas Finitos No
DeterminÃ­sticos
DiseÃ±o de Compiladores
Dr. VÃ­ctor de la Cueva
vcueva@tec.mx
1
AutÃ³mata Finito No DeterminÃ­stico (NFA)
Â— En realidad, cualquier conjunto que sea aceptado por un
NFA podrÃ¡ ser aceptado por un FA (o DFA).
Â— Sin embargo, el NFA es un concepto Ãºtil en la prueba de
teoremas y el concepto de no-determinÃ­stico juega un papel
fundamental tanto en la teorÃ­a de lenguajes como en la
teorÃ­a de la computaciÃ³n.
Â— Para crear el nuevo modelo NFA considere modificar el
modelo de FA para permitir 0, 1 o mÃ¡s transiciones de un
estado con el mismo sÃ­mbolo de entrada.
Â— TambiÃ©n se pueden formar diagramas de transiciÃ³n para un
NFA.
2
20/05/25
2
Control de movimientos
Â— Una de las distinciones cruciales entre las clases de autÃ³matas
finitos es si el control es:
â—¦ DeterminÃ­stico, que significa que el autÃ³mata no puede estar en mÃ¡s de un
estado en cualquier tiempo.
â—¦ No-determinÃ­stico, que significa que puede estar en muchos estados a la
vez.
Â— Descubriremos que agregando no-determinismo no nos ayuda a
definir ningÃºn lenguaje que no pueda ser definido usando autÃ³matas
determinÃ­sticos, pero son mÃ¡s eficientes las describir la aplicaciÃ³n.
Â— El no-determinismo nos ayuda a â€œprogramarâ€ la soluciÃ³n en
lenguaje de â€œalto-nivelâ€.
Â— Posteriormente, el AutÃ³mata No DeterminÃ­stico es â€œcompiladoâ€
para transformarlo en uno DeterminÃ­stico, el cual es ejecutado.
3
Secuencia aceptada por un NFA
Â— Una secuencia de entrada a1 a2 ...an es aceptada por un NFA
si existe una secuencia de transiciones, correspondientes a la
secuencia de entrada, que lleva al NFA de un estado inicial a
un estado final.
Â— En un DFA, para un string w y un estado q dados, existe una
Ãºnica transiciÃ³n para cada sÃ­mbolo.
â—¦ Para determinar si un string es aceptado por un DFA basta verificar
si existe este Ãºnico camino.
Â— Para un NFA hay muchos caminos etiquetados con w.
â—¦ Para determinar si un string w es aceptado, TODOS deben ser
checados para verificar si al menos 1 termina en un estado final.
20HU
4
20/05/25
3
Ejemplo
a,b
b b
Â— Representa el conjunto de strings en el alfabeto {a,b} que
terminan en bb.
Â— Su tabla de transiciÃ³n es a conjuntos de estados.
Â— Para ver si un string es aceptado se deben seguir todos los
caminos, lo cual forma un Ã¡rbol.
Estad
o
a b
0 {0} {0,1}
1 {} {2}
2 {} {}
5
Ejemplo de aceptaciÃ³n de un string
Â— Veamos si el string w = abb es aceptado por el autÃ³mata
anterior:
a,b
b b
0
0 1
b b
0
0
a
0
0 1
b b 1
2
b
6
20/05/25
4
Ejemplos
Â— Un NFA que acepte strings que tengan dos 0â€™s o dos
1â€™s consecutivos.
Â— Un NFA que acepte strings con la secuencia abba.
Â— Hacer primero el DFA y luego el NFA.
20HU
160Su
7
Formalmente
Â— Denotamos un NFA por medio de una 5-tupla (Q, S, d, q 0 , F), donde
todos los elementos tienen el mismo significado que un FA excepto d
que ahora mapea Q X S Â® 2Q
, donde 2Q es el conjunto potencia de Q
(el conjunto de todos los posibles subconjuntos de Q).
Â— La intenciÃ³n es que d(q,a) es el conjunto de todos los estados p tales
que hay una transiciÃ³n de q a p etiquetada con a.
Â— La funciÃ³n d puede ser extendida a !ğ›¿ que mapea de Q X S* Â® 2Q y se
refiere a secuencias de entradas:
1. #ğ›¿ ğ‘, ğœ– = ğ‘
2. #ğ›¿ ğ‘, ğ‘¤ğ‘ = ğ‘ ğ‘ğ‘ğ‘Ÿğ‘ ğ‘ğ‘™ğ‘”Ãºğ‘› ğ‘’ğ‘ ğ‘¡ğ‘ğ‘‘ğ‘œ ğ‘Ÿ ğ‘’ğ‘› #ğ›¿ ğ‘, ğ‘¤ , ğ‘ ğ‘’ğ‘ ğ‘¡Ã¡ ğ‘’ğ‘› ğ›¿(ğ‘Ÿ, ğ‘)}
21HU
8
20/05/25
5
ExtensiÃ³n
Â— Note que !ğ›¿ ğ‘, ğ‘ = ğ›¿ ğ‘, ğ‘ para un sÃ­mbolo de entrada
a.
Â— De esta forma, nuevamente usaremos el sÃ­mbolo d en
lugar de !ğ›¿.
Â— TambiÃ©n es Ãºtil extender d a argumentos en 2 Q X S*:
3. ğ›¿ ğ‘ƒ, ğ‘¤ = â‹ƒ ;âˆˆ= ğ›¿(ğ‘, ğ‘¤)
para cada conjunto de estados P Ã Q
L(M) ,donde M es el NFA (Q, S, d, q0, F), es
{ğ‘¤|ğ›¿ ğ‘# , ğ‘¤ ğ‘ğ‘œğ‘›ğ‘¡ğ‘–ğ‘’ğ‘›ğ‘’ ğ‘¢ğ‘› ğ‘’ğ‘ ğ‘¡ğ‘ğ‘‘ğ‘œ ğ‘’ğ‘› ğ¹} 21HU
9
Equivalencia de DFAs y NFAs
Â— Teorema: Sea L un conjunto aceptado por un NFA.
Entonces, existe un DFA que acepta a L.
Â— DemostraciÃ³n (construcciÃ³n): La prueba dependerÃ¡ de
mostrar que los DFAs pueden simular NFAs; esto es, para
cada NFA podemos construir un DFA equivalente (uno que
acepte el mismo lenguaje)
â—¦ La forma en la que un DFA simula un NFA es permitiendo que los
estados de un DFA correspondan a conjuntos de estados del NFA.
â—¦ El DFA que se construye asÃ­, realiza un seguimiento en su control
finito de todos los estados en los que el NFA podrÃ­a estar despuÃ©s
de leer la misma entrada que el DFA ha leÃ­do.
22HU
10
20/05/25
6
CreaciÃ³n de un DFA a partir de un NFA
Â— La demostraciÃ³n anterior proporciona un mÃ©todo
para crear un DFA que acepte el mismo lenguaje que
un NFA (un DFA equivalente).
Â— El estado inicial es el subconjunto [q 0], donde q 0 es el
estado inicial del NFA (ver mÃ©todo en ejercicio).
Â— En la prÃ¡ctica, es comÃºn que muchos de los estados de
un DFA equivalente no puedan ser alcanzados a partir
de [q 0], por lo que no deben estar en la tabla final.
Â— Se recomienda iniciar con [q 0] e ir agregando estados
a la tabla, dependiendo de cuÃ¡les sÃ­ se pueden alcanzar.
23HU
164-165 Su
11
NFA con movimientos-ğœ–
Â— Se puede extender el modelo de NFA para que incluya
transiciones con la entrada nula ğœ–.
Â— Ejemplo: Un NFA que acepta el lenguaje consistente en
cualquier nÃºmero de 0â€™s (incluyendo 0), seguido de
cualquier nÃºmero de 1â€™s y seguido de cualquier nÃºmero
de 2â€™s.
Â— Desde luego, se pueden incluir aristas etiquetadas con ğœ–
en el camino de aceptaciÃ³n aÃºn y cuando las ğœ–â€™s no
aparezcan explÃ­citamente en el string w.
24HU
24HU
12
20/05/25
7
Formalmente
Â— Un NFA con ğœ–-moves es una quÃ­ntupla (5-tupla)
(Q,S,d,q0,F) con todos los componentes definidos igual
que para un NFA, pero con d, la funciÃ³n de transiciÃ³n,
que mapea Q X (S Ãˆ {ğœ–}) Â® 2 Q.
Â— La intenciÃ³n es que d(q,a) consista de todos los estados
p tales que hay una transiciÃ³n de p a q, etiquetada con a,
donde a es un sÃ­mbolo de S o ğœ–.
Â— Desde luego que se puede crear una tabla de transiciÃ³n
para definir d, donde ahora se agrega ğœ– como una posible
entrada.
25HU
166-167 Su
13
"ğ›¿
Â— Como siempre, extendemos d a una funciÃ³n !ğ›¿ que mapea
QXS*Â® 2Q .
Â— !ğ›¿(q,w) debe dar todos los estados p, tales que se pueda ir
de q a p con un camino etiquetado w, quizÃ¡ incluyendo
aristas etiquetadas con ğœ–.
Â— Obviamente, en la construcciÃ³n del !ğ›¿ es importante
encontrar el conjunto de estados alcanzables de un estado q
dado, usando transiciones ğœ–.
Â— Usamos ğœ– âˆ’ ğ¶ğ¿ğ‘‚ğ‘†ğ‘ˆğ‘…ğ¸ para denotar el conjunto de todos
los vÃ©rtices p tales que hay un camino de q a p etiquetado ğœ–.
14
20/05/25
8
ğœ–-CLOSURE(q)
Â— Para extender d a !ğ›¿ es necesario calcular el conjunto de
estados alcanzables a partir de un estado q usando una
transiciÃ³n ğœ–.
Â— Se utiliza ğœ–-CLOSURE(q) para denotar el conjunto de todos
los vÃ©rtices p tales que hay un camino de q a p etiquetado
con ğœ–.
Â— TambiÃ©n se puede calcular ğœ–-CLOSURE(P), donde P es un
conjunto de estados, como:
âˆˆ âˆ’ğ¶ğ¿ğ‘‚ğ‘†ğ‘ˆğ‘…ğ¸ ğ‘ƒ = ,
!âˆˆ#
ğœ– âˆ’ ğ¶ğ¿ğ‘‚ğ‘†ğ‘ˆğ‘…ğ¸(ğ‘)
25HU
15
DefiniciÃ³n formal de ğœ–-CLOSURE
Â— Se hace en forma recursiva.
Â— La ğœ–-CLOSURE de un estado q i, denotada por ğœ–-
CLOSURE(q i), es definida recurrentemente por:
â—¦ Base: q i Ã ğœ–-CLOSURE(q i )
â—¦ Recursivo: Sea q j un elemento de ğœ–-CLOSURE(q i ).
Si q k Ã d(q j ,Ã), entonces q k Ã ğœ–-CLOSURE(q i ).
â—¦ Cerradura: ...
16
20/05/25
9
DefiniciÃ³n de "ğ›¿
Â— Se puede entonces definir -ğ›¿ como sigue:
1. !ğ›¿ q, Îµ = ğœ– âˆ’ ğ¶ğ¿ğ‘‚ğ‘†ğ‘ˆğ‘…ğ¸ ğ‘
2. Para wÃS* y aÃS, !ğ›¿ ğ‘, ğ‘¤ğ‘ = ğœ– âˆ’ ğ¶ğ¿ğ‘‚ğ‘†ğ‘ˆğ‘…ğ¸ ğ‘ƒ , donde
P = {p|para alguna r
Ã !ğ›¿(q,w), p
Ãd(r,a)}
Â— Es conveniente extender d y -ğ›¿ a conjuntos de estados R como:
3. ğ›¿ ğ‘…, ğ‘ = â‹ƒ !âˆˆ$ ğ›¿ ğ‘, ğ‘ , y
4. !ğ›¿ ğ‘…, ğ‘¤ = â‹ƒ !âˆˆ$ !ğ›¿(ğ‘, ğ‘¤)
Â— En este caso
d(q,a) no necesariamente es igual a .Î´(q,a) ya que
incluye paths etiquetados con a (incluyendo paths etiquetados por
ğœ–). Ni -ğ›¿(q, ğœ–) es necesariamente igual a
d(q,ğœ–).
17
FunciÃ³n de transiciÃ³n de entrada t
Â— La funciÃ³n de transiciÃ³n de entrada t de un NFA-Ã M es
una funciÃ³n de QXSÂ®2 Q, definida por:
ğ‘¡(ğ‘8 , ğ‘) = 8
9> âˆˆ âˆˆ;<=>?@AB(9? )
ğœ– âˆ’ ğ¶ğ¿ğ‘‚ğ‘†ğ‘ˆğ‘…ğ¸(ğ›¿ ğ‘C , ğ‘ )
Donde d es la funciÃ³n de transiciÃ³n de M.
18
20/05/25
10
Tres partes para t
Â— t(q i,a) puede ser separada en 3 partes:
1. Obtener el conjunto de estados que pueden ser alcanzados de q i
sin procesar un solo sÃ­mbolo, es decir, con
Ã-moves, los cuales NO
estÃ¡n en t.
2. Obtener el conjunto de estados que pueden ser alcanzados al
procesar un sÃ­mbolo a de todos los estados del conjunto, los
cuales estÃ¡n en t.
3. Obtener el conjunto de estados a los que se puede llegar con los
Ã-arcos a partir del conjunto obtenido en 2, los cuales, tambiÃ©n
estÃ¡n en t.
NOTA: Para un NFA (sin Ã-moves) la t es la misma que su d. La
funciÃ³n t es usada para construir un DFA equivalente.
171Su
19
Equivalencia entre NFA y NFA-ğœ–
Â— Igual que el no-determinismo, la habilidad para hacer
transiciones con ğœ– no permite a un NFA aceptar
conjuntos no regulares.
Â— Esto se mostrarÃ¡ simulando un NFA con ğœ–-moves por
medio de un NFA sin tales transiciones.
Â— Teorema. Si L es aceptado por un NFA con ğœ–-moves,
entonces L es aceptado por un NFA sin ğœ–-moves.
Â— DemostraciÃ³n: Es por un procedimiento de
construcciÃ³n... 26HU
171Sud
20
20/05/25
11
ConstrucciÃ³n de un DFA a partir de un NFA-Ã
172Su
Tomado de [1] pp. 172
27HU
21
Lenguaje aceptado
Â— Se define L(M), el lenguaje aceptado por M = (Q, S, d, q0,
F) como w !ğ›¿(ğ‘# , ğ‘¤ ğ‘ğ‘œğ‘›ğ‘¡ğ‘–ğ‘’ğ‘›ğ‘’ ğ‘¢ğ‘› ğ‘’ğ‘ ğ‘¡ğ‘ğ‘‘ğ‘œ ğ‘’ğ‘› ğ¹} 26HU
22
20/05/25
12
Equivalencia de DFA y RE
Â— El plan serÃ¡ mostrar por inducciÃ³n sobre el tamaÃ±o
(nÃºmero de operadores en) de una expresiÃ³n regular
que hay un NFA con ğœ–-transitions denotando
el mismo lenguaje.
Â— Esta demostraciÃ³n, junto con los teoremas de
equivalencia anteriores: NFA
NFA con
ğœ–-transitions
RE
DFA
23
RE a NFA
Â— Teorema. Sea r una expresiÃ³n regular. Entonces, existe
un NFA con ğœ–-transitions que acepte L(r).
Â— DemostraciÃ³n:... 30HU
24
20/05/25
13
ConstrucciÃ³n de un NFA a partir de una RE
r = Ã
r = Ã†
r = a
r = r1 + r 2
r = r1r2
r = r1* 32HU
25
DFA a RE
Â— Teorema: Si L es aceptado por un DFA, entonces, L es
denotado por una expresiÃ³n regular.
Â— DemostraciÃ³n:... 33HU
26
20/05/25
14
ConstrucciÃ³n de una RE a partir de un DFA
Â— La equivalencia de procesos de un DFA y sus caminos nos proporciona
un mÃ©todo heurÃ­stico para determinar el lenguaje que es aceptado por
un DFA.
Â— Los strings aceptados en un estado qi (estado final) son precisamente
aquellos deletreados por el camino de q0 a qi .
Â— Podemos entonces separar la determinaciÃ³n de esos caminos en dos
partes:
â—¦ Encontrar las expresiones regulares u 1 , ..., u n para los strings en todos los
caminos de q 0 que alcanzan q i por primera vez.
â—¦ Encontrar las expresiones regulares v1 , ..., vm para todos los caminos que dejan
q i y regresan a q i .
â—¦ Los strings aceptados por q i son (u1 Ãˆ ... Ãˆ u n )(v1 Ãˆ ... Ãˆ vm )*.
Â— Los strings aceptados por el DFA son la uniÃ³n de los aceptados por cada
estado final qi .
152Su
27
Referencias
1. T.A. Sudkamp. Languages and Machines: An Introduction
to the Theory of Computer Science. Pearson, 3rd
Edition (2005).
2. J.E. Hopcroft, R. Motwani, J.D. Ullman. Introduction to
Automata Theory, Languages, and Computation. Pearson,
3rd Edition (2006).
28
